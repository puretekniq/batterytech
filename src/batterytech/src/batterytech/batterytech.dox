// this file is only for doxygen

namespace BatteryTech {

/*! \mainpage Welcome to BatteryTech SDK
 *
 * \section starting_sec Getting Started
 *
 * This is some info on getting started
 *
 * \section install_sec Installation
 *
 * \subsection step1 Step 1: Opening the box
 *
 * etc...
 */


// now let's define groups

/**
 * \defgroup Entry Application Entry Points
 * \brief How your application comes to life
 *
 * A state-driven application such as a game generally has 2 phases:  Updating (calculating positions, object states, processing, triggering, etc) and Rendering to screen.
 *
 * Almost every game or high-performance application can be efficiently driven off of this paradigm, so BatteryTech requires that the following classes are extended:
 *
 * \ref BTApplicationUpdater which is used to update the application state\n
 * \ref BTApplicationRenderer which is used to render the application with OpenGL ES\n
 * BT gains access to your implementations of these two classes via an extended context which a BT app must provide via a global implementation of the following:\n
 * \ref btAppCreateContext
 *
 * Here is a basic example:
 * \code
 *  // AppContext.h
 * class AppContext : public Context {
 * public:
 *     AppContext(GraphicsConfiguration *gConfig);
 *     virtual ~AppContext();
 *     HelloWorldApp *app;
 * };
 *  //
 *  // AppContext.cpp
 * AppContext::AppContext(GraphicsConfiguration *gConfig) : Context(gConfig) {
 *     app = new HelloWorldApp(this);
 *     appUpdater = app;
 *     appRenderer = app;
 * }
 * //
 * AppContext::~AppContext() {
 *     delete app;
 *     app = NULL;
 * }
 * //
 *  // App.h
 * class App : public BTApplicationUpdater, public BTApplicationRenderer {
 * public:
 *     HelloWorldApp(AppContext *context);
 *     virtual ~HelloWorldApp();
 *     virtual void update();
 *     virtual void render();
 * }
 * //
 *  // App.cpp
 * Context* btAppCreateContext(GraphicsConfiguration *graphicsConfig) {
 *     return new GameContext(graphicsConfig);
 * }
 * \endcode
 *
 * So you can have a single class extend both BTApplicationUpdater and BTApplicationRenderer, or you also have the option of having different classes extend
 * each of those classes respectively.  However you want to set up your entry, you have complete control of that by extending Context with your application's context.
 */
 
/**
 * \defgroup FileIO File Asset Reading and Writing
 * \brief File Assets, File IO, Directories and Paths
 *
 * Reading may happen from an Android APK, iOS/OSX Bundle or a plain old Windows, Linux or other file system.  Many of the supported input systems
 * can not be written to so it is recommended that an application developer always plan on writing to external or application storage (whichever is more
 * appropriate) instead of ever assuming that the input files may ever be written to.
 *
 * Loading and freeing an asset example:
 * \code
 * S32 size;
 * unsigned char* data = _platform_load_asset("myasset.dat", &size);
 * if (data) {
 *     // process data of size
 * }
 * _platform_free_asset(data);
 * \endcode
 */
 
 /**
 * \defgroup UserInput User Input
 * \brief Getting User Input
 * \defgroup Touch Touch Input
 * \brief Touch and Pointer Input Support
 * \ingroup UserInput
 * \defgroup Keyboard Keyboard
 * \brief Keyboard Support
 * \ingroup UserInput
 * \defgroup Accelerometer Accelerometer
 * \brief Accelerometer Support
 * \ingroup UserInput
 * \addtogroup UserInput
 *
 * User Input comes in many forms.  The standard ways that BatteryTech supports it are in the following forms:
 * Touch and Pointer Input, Keyboard Input and Accelerometer Input
 */
 
 /**
  * \addtogroup Touch
  *
  * BT uses platform-independent touch remapping and a simple polling model to make it extremely easy for you to access multitouch data for up to
  * 10 touch points.  On desktop platforms, mouse input is mapped to the first available touch point so the same code will work for everything.
  *
  * Example for reading a single touch point
  * \code
  * PointerState state = context->pointerState[0];
  * if (state.isDown) {
  *   // touch is down at state.x, state.y
  * }
  * \endcode
  *
  * And handling multi touch isn't really any harder.  Here's an example to allow for multiple touches on multiple objects:
  * \code
  * for (S32 i = 0; i < MAX_POINTERS; i++) {
  *   PointerState state = context->pointerState[i];
  *   if (state.isDown) {
  *     checkObjectTouchIntersection(state.x, state.y);
  *   }
  * }
  * \endcode
  */

 /**
 * \addtogroup Keyboard
 *
 * Most mobile platforms have virtual keyboards that we can use in place of real keyboards.  Different platforms have different special keys that
 * we can check for the existance of.
 *
 * Reading keyboard input can be done in one of two ways:
 *
 * Some example code:
 * \code
 * U8 key = context->keyPressed;
 * if (key) {
 *     // key is the most recent key pressed
 * }
 * if (context->specialKeyPressed) {
 *     if (context->specialKeyPressed == SKEY_BACK) {
 *         // go back
 *     }
 * }
 * \endcode
 *
 * And for multikey checks:
 * \code
 * for (S32 i = 0; i < MAX_KEYSTATES; i++) {
 *     KeyState ks = context->keyState[i];
 *     if (ks.isDown) {
 *         // ks.keyCode is the key that's down right now
 *     }
 * }
 * \endcode
 *
 */

/**
 * \addtogroup Accelerometer
 *
 * Most mobile platforms come standard with accelerometers and for those, we have them enabled and feeding data into your BatteryTech app by default.
 *
 * The most recent data is always available in Context::accelerometerState.  The data is normalized across all platforms so no special handling code
 * is needed to use it consistently.
 *
 * Example:
 * \code
 * AccelerometerState accel = context->accelerometerState;
 *   // accel.x, accel.y and accel.z are all you need!
 * \endcode
 */

/**
 * \defgroup UI User Interface Library
 * \brief OpenGL-based User Interface Library
 * 
 * User Interface libraries can be very large and cumbersome to meet the demands of every application.  BT's UI library (BTUI) takes the opposite approach.  
 * It is designed primarily to provide menus for mobile games using GLES.  It is very lightweight, has very few components and can do this job very well.
 * 
 * 
 * * Base Components
 * 
 * A \ref UIComponent is a piece of text, button, panel, layout or any other thing that you will find on a UI.  Every BTUI component like Button, Checkbox, etc,
 * extends \ref UIComponent.
 * 
 * 
 * * Menus
 * 
 * BTUI is menu-centric.  A \ref Menu is the controller and holds the top level \ref UIComponent.  Menus receive the user input for all components that they hold.
 * Menus instantiate components into a layout.  Each menu in an app must be instantiated and added to the \ref UIManager.
 * 
 * 
 * * Menu Management
 * 
 * \ref UIManager is used to show and hide menus.  It does a little more than that, though.  It also has a menu stack that it manages.  Every time you show a
 * menu, it pushes that menu onto a stack.  This means you can drill-down in menus and not worry about what menu the last one came from.  Let's examine 
 * the methods quickly:
 * 
 * \code
 * S32 addMenu(Menu *menu);
 * void showMenu(const char *name);
 * void showMenu(const char *name, void *data);
 * void popMenu();
 * void clearMenuStack();
 * \endcode
 * 
 * The first method, addMenu() is what you call from your game to put an instance of a menu in the pool.  Each menu will only have one instance of it which 
 * is held throughout the application.  The advantage of this is that the menu will hold its state until the application is closed.  Typical usage:
 * 
 * \code
 * context->uiManager->addMenu(new TopMenu());
 * \endcode
 * 
 * The UIManager will free your menus for you when it is freed, so you don't need to hang on to references to them unless you need them for a different reason.  
 * Just know that it will free for you.
 * 
 * After a menu has been added, showing it is as simple as:
 * 
 * \code
 * context->uiManager->showMenu(TOP_MENU_NAME); // TOP_MENU_NAME would be declared either in constants or in the TopMenu header itself.
 * \endcode
 * 
 * Now the menu will be showing and it will also be on top the menu stack in UIManager.  The menu itself can have a click handler that can remove it from the 
 * stack, like so:
 * \code
 * context->uiManager->popMenu();
 * \endcode
 * If the stack was empty before showing that menu, nothing will be shown, but if it had any items, the top most item is now the menu displayed in front.
 * 
 * showMenu() can also take a second argument, data.  Being a void pointer, you can send a pointer to anything using this function.  What happens when you use 
 * it is that the menu being shown will get a call to void setData(void *data) and being that menus are single-instance, it can store that data or process it 
 * in any way which will prepare it for being displayed or having a state set.
 * 
 * 
 * * Layouts
 * 
 * The most important thing to understand about BTUI is the \ref LinearLayout.  This \ref UIComponent is the do-all layout and it can be nested, which makes for limitless
 * layout possibilities.  A LinearLayout can be either vertical or horizontal.  Vertical layout stacks the items one on top of another, or bottom up, centered 
 * or any combination of the 3.  Horizontal layout does the same, but using left-to-right placement.
 * 
 * \code
 * mainLayout = new LinearLayout(LinearLayout::VERTICAL);
 * \endcode
 * 
 * is a typical way of creating a \ref LinearLayout.  This one will be in the vertical orientation.  Specify HORIZONTAL for horizontal.  Each object added will have
 * its own positioning in the layout and that is specified by the LayoutParameters set to that specific object.  
 * 
 * \code
 * backButton->setLayoutParameters(new LayoutParameters(LayoutParameters::HORIZONTAL_CENTER, LayoutParameters::TOP));
 * \endcode
 * 
 * will set the back button to be centered horizontally and added to the top.  See LayoutParameters.h for all possible options.
 * 
 * Each \ref UIComponent will also specify Size, Margins and Padding.  All units are in what we call "Reference units."
 * 
 * 
 * * Reference Units
 * 
 * Very similar to density-independent pixels, reference units are units of relative size to the screen size of the device or window, keeping everything 
 * proportionate.  The reference size is specified in batterytech_config.txt as "reference_width" and "reference_height"
 * 
 * These dimensions are your reference units.  For example, if you use these settings and specify 480x800 as your screen size, then no matter what the actual 
 * screen size is, it will appear as 480x800 to your UI for measurement purposes.  It means that if you make a button 480 units wide, that it will ALWAYS 
 * be screen-width no matter what the resolution of your target device is!  This delivers very predictable results and makes it very easy to design a user 
 * interface that you know will work almost everywhere.
 * 
 * If you change your reference size, you will inevitably have to change all of the numbers you've used for your component sizes and layouts.
 * 
 * 
 * * Sizes, Margins and Padding
 * 
 * Every UIComponent can have a Size, Margins and Padding.  These are specified in Reference Units as described above.  Size can have 2 special macros:  
 * FILL and WRAP.  FILL tries to consume all available space while WRAP tries to only use as much as the contents of the UIComponent require.
 * 
 * 
 * * Rendering
 * 
 * Rendering for standard BTUI components is handled by MenuRenderer.cpp.  Rendering will be done in either Fixed-Function GL or Shader-based, depending on 
 * settings and capabilities.  Resources used for rendering each UIComponent must be specified before the Renderer is initialized.  Specifying resources is 
 * very easy.  Here is a complete example of a button being added to a menu with corresponding background images set.
 * 
 * 
 * * Working example
 * \code
 * S32 buttonBgId = context->menuRenderer->addTextureAsset(UI_BUTTON_1);
 * S32 buttonPressedBgId = context->menuRenderer->addTextureAsset(UI_BUTTON_1_PRESSED);
 * backButton = new Button("Back");
 * backButton->userId = -2;
 * backButton->setLayoutParameters(new LayoutParameters(LayoutParameters::HORIZONTAL_CENTER, LayoutParameters::TOP));
 * backButton->setSize(FILL, 60);
 * backButton->setMargins(5);
 * backButton->setBackgroundMenuResource(buttonBgId);
 * backButton->setPressedBackgroundMenuResource(buttonPressedBgId);
 * backButton->setClickDownSoundAsset(UI_CLICK_DOWN_ASSETNAME);
 * \endcode
 * This button uses the texture defined as UI_BUTTON_1 for unclicked state and UI_BUTTON_1_PRESSED for clicked state.  It will display the text "Back" and 
 * will be top centered horizontally.  It will fill up all horizontal area and be 60 units tall.  It will be 5 units in from its container and will play the 
 * sound UI_CLICK_DOWN_ASSETNAME when clicked.
 * 
 * 
 * * Animation
 * 
 * A simple animation framework is provided that allows you to write your own animators using OpenGL, which is particularly powerful when paired with Shaders.  
 * There is one stock animator (SlideAnimator) that slides components in and out of the menu.  It is used in the demo app and should be a good place to look to 
 * learn how to use it.  For custom animators, you will need to extend UIAnimator and implement the following functions:
 * 
 * \code
 * virtual void update(F32 delta){};
 * virtual void drawPreComponent(Context *context){};
 * virtual void drawPostComponent(Context *context){};
 * \endcode
 * 
 * update is called every engine tick with delta being the time difference from the last tick.
 * drawPreComponent is called before the normal drawing routing of UIComponent.
 * drawPostComponent is called right after normal drawing.  The two methods, used in conjunction, allow for setting up transformations or setting and resetting 
 * GL states or anything else.
 * 
 * Each component specifies the animator it will use and for what part of its display the animator will be applied to:
 * 
 * \code
 * virtual void setEnterAnimator(UIAnimator *animator);
 * virtual void setMainAnimator(UIAnimator *animator);
 * virtual void setExitAnimator(UIAnimator *animator);
 * \endcode
 * 
 * The "Enter" animator is run when the menu is being shown.
 * The "Main" animator is run constantly while the component is being shown.
 * The "Exit" animator is run when the menu is exiting.
 * 
 * 
 * * Scrollable Container
 * 
 * The \ref ScrollableContainer class is a layout that can only have one UIComponent.  To make a block of text scrollable, simple create a ScrollableContainer, add
 * the text to it and set the layouts appropriately to allow for multiline text wrapping.  You may add a LinearLayout to the ScrollableContainer instead of a 
 * normal UIComponent allowing for multiple components to be scrolled together, which can include labels, buttons, checkboxes or any other component.  Rendering 
 * is achieved through the use of glScissor.  Please keep in mind that as of BatteryTech 1.0c, all components in a ScrollableContainer are always rendered in the 
 * clipped space, which may be a performance problem depending on your content.  Future optimizations may determine which objects or lines of text are occluded 
 * and forego rendering on them.
 */
 
/**
 * \defgroup Audio Audio playback and management
 * \brief Audio Sample and (local) Streaming playback
 *
 * BT implements audio in 2 different ways.  It provides its own OGG decoding, pcm mixing and playback services and it also supports calling platform-specific 
 * functions when supported.  In environments like Win32, there are no one-stop shops for playing OGGs in a way that would be good for games, but in Android, 
 * there are services like the SoundPool and MediaPlayer classes.  BT supports both of those if you choose to use them.
 *
 * The setting "prefer_platform_audio_management" in batterytech_config.txt defines the behavior.  If set to true, then sound playing calls will use platform 
 * facilities such as Android's SoundPool when available.  If set to false, BT's PCM audio services will be used instead.  As of BT 2.0, only Android has 
 * platform audio management support.  It will likely be added for iOS and OSX at some point in the form of OpenAL.
 *
 * Formats: BatteryTech supports OGG-Vorbis exclusively.
 *
 * _platform audio functions are available primarily to serve the \ref BatteryTech::AudioManager.
 * For most applications, \ref BatteryTech::AudioManager is the desired interface to use and can
 * be accessed through the application's \ref BatteryTech::Context.
 *
 * Example:
 * \code
 * context->audioManager->loadSound("sounds/mysound.ogg");
 * context->audioManager->playSound("sounds/mysound.ogg", 0, 1.0, 1.0, 1.0);
 * context->audioManager->unloadSound("sounds/mysound.ogg");
 * \endcode
 */
 
 /**
 * \defgroup Networking Networking
 * \brief POSIX Socket-based network support
 *
 * Most platforms natively support standard BSD or POSIX sockets but for those that don't, simply including \ref platformgeneral.h will include, define or redefine
 * macros to support POSIX.  Applications can count on standard functions such as socket, bind, setsockopt, send, recv, inet_pton, inet_ntop, getaddrinfo and getnameinfo
 *
 * A few specific functions that are not defined as part of the POSIX sockets specification are implemented as _platform functions and documented here.
 *
 * For more information on using Berkeley/POSIX sockets, please visit the wikipedia link in the see also section.
 *
 * BatteryTech includes a default implementation of message-based client/host game networking in the following classes:
 * \ref BatteryTech::NetworkManager, \ref BatteryTech::GameConnection, \ref BatteryTech::NetworkMessage
 *
 * \see http://en.wikipedia.org/wiki/Berkeley_socket
 */
 
 /**
 * \defgroup Vibration Vibration Control
 * \brief Support for vibration effect playback
 *
 * Most systems do not have robust vibration control, but specifically on Android, there are systems such as Immersion Technology's Motiv or UHL
 * which can play a variety of effects at various intensities.  Such systems will need to be integrated on the Android platform side.  Stock Android
 * vibration support can also be integrated instead.  Please follow the instructions in the section on Integrating platform-specific systems for
 * additional information.
 */
 
/*! \defgroup Primitives Primitive Types
 *
 * \brief BatteryTech defines primitive types for cross-platform compatibility.
 *
 * Common typedefs include:\n
 * \ref S8, \ref S16 and \ref S32 = Signed 8, 16 and 32 bit integers respectively\n
 * \ref U8, \ref U16 and \ref U32 = Unsigned 8, 16 and 32 bit integers respectively\n
 * \ref BOOL32 for booleans with \ref TRUE and \ref FALSE as values\n
 * \ref F32 and \ref F64 = 32 bit and 64 bit floating point number\n
 *
 * Example:
 * \code
 * BOOL32 found = FALSE;
 * for (S32 i = 0; i < numObjects; i++) {
 *     if (matches(objects[i])) {
 *         found = TRUE;
 *         break;
 *     }
 * }
 * \endcode
 * \see \ref primitives.h for detailed information
 */
 
 /**
 * \defgroup Hooks Platform Hooks
 * \brief Customizing per-platform and integrating with 3rd party systems
 *
 * \defgroup AndroidHooks Customizing Android
 * \brief Customizing Android with platform hooks
 *
 * Customizing your Android build is as simple as extending BatteryTechActivity and adding your customizations or overriding the hook methods.
 *
 * Example:
 * \code{.java}
 * class MyActivity extends BatteryTechActivity implements BatteryTechHookHandler {
 *
 *	@Override
 *	public BatteryTechHookHandler getHookHandler() {
 *		// with this, we are declaring that this class will be handling the hook functions
 *		return this;
 *	}
 *
 * 	@Override
 *	public GLSettings createGLSettings() {
 * 		// we need to use only GLES 2.0 for this application
 * 		return new GLSettings() {
 * 			@Override
 * 			public boolean supportGLES2() {
 * 				return true;
 * 			}
 * 		};
 * 	}
 *
 * 	public void showAd() {
 * 		// integrate with your ad provider
 * 	}
 *
 * 	public void hideAd() {
 * 		// integrate with your ad provider
 * 	}
 *
 * 	public String hook(String hook) {
 * 		// easily handle custom behavior here
 * 		if (hook.startsWith("showCameraPreview")) {
 * 			// insert our camera preview under the batterytech view
 * 		} else if (hook.startsWith("hideCameraPreview")) {
 * 			// if shown, remove our camera preview
 * 		}
 * 	}
 * }
 * \endcode
 *
 * In addition to the extension capabilities, you have a standard Android project of which you can use out-of-the-box solutions for a number of 3rd party providers.
 * Please review the standard Android developer documentation for details about customizing the manifest or selecting deployment options.
 *
 * \ingroup Hooks
 *
 * \defgroup iosHooks Customizing iOS
 * \brief Customizing iOS with platform hooks
 *
 * Your iOS build comes in the form of a standard XCode project of which there is a single view controller, batterytechViewController.  Extending batterytechViewController
 * gives you the flexibility to add other views over or under your EAGLView (the primary view BT uses) or integrate with 3rd party products.
 *
 * Example:
 * \code
 *  // MyBTViewController.h
 * #import "batterytechViewController.h"
 *
 * @interface MyBTViewController : batterytechViewController
 * @end
 *  //
 *  //
 *  // MyBTViewController.m
 *
 *  #import "MyBTViewController.h"
 *
 *  @interface MyBTViewController ()
 *  @end
 *
 *  @implementation MyBTViewController
 *  - (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil
 *  {
 *      self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil];
 *      if (self) {
 *          // Custom initialization
 *      }
 *      return self;
 *  }
 *
 *  - (void)viewDidLoad
 *  {
 *      [super viewDidLoad];
 *      // Do any additional setup after loading the view from its nib.
 *  }
 *
 *  - (void)viewDidUnload
 *  {
 *      [super viewDidUnload];
 *      // Release any retained subviews of the main view.
 *      // e.g. self.myOutlet = nil;
 *  }
 *
 *  // BatteryTech overrides (the reason we created this subclass)
 *
 *  - (void)showAd {
 *  }
 *
 *  - (void)hideAd {
 *  }
 *
 *  - (void)hook:(const char*)hookData withResult:(char*) result withResultLen:(int) resultLen {
 *  	if (strStartsWith(hookData, "showCameraPreview")) {
 *  		// fire up the camera preview and insert the view into the chain
 *  	} else if (strStartsWith(hookData, "hideCameraPreview")) {
 *  		// if we're showing the camera, hide it now
 *  	}
 *  }
 *
 *  - (bool) useGLES2 {
 *      return TRUE;
 *  }
 *
 *  - (bool) forceLandscape {
 *      return TRUE;
 *  }
 *
 *  @end
 * \endcode
 *
 * Because a standard XCode project is used, virtually any library or third party application can be integrated with your BT App using standard techniques.  Please consult
 * Apple's developer documentation for additional details about developing for iOS.
 *
 * \ingroup Hooks
 *
 * \defgroup winHooks Customizing Windows
 * \brief Customizing Windows with platform hooks
 *
 * Every BatteryTech application includes a file called WinHooks.cpp which defines the hook functionality for the Windows platform.
 *
 * Here is a quick example of a loopback to give a positive purchase result:
 *
 * \code
 * void winHook(const char *hook, char *result, S32 resultLen) {
 * 	// Handle custom hooks here
 * 	if (strStartsWith(hook, "requestPurchase")) {
 * 		// call back with success
 * 		char hookData[512];
 * 		strcpy(hookData, hook);
 * 		strtok(hookData, " ");
 * 		char *productId = strtok(NULL, " ");
 * 		char callback[512];
 * 		sprintf(callback, "purchaseSucceeded %s", productId);
 * 		btCallback(callback);
 * 		cout << callback << endl;
 * 	}
 * }
 * \endcode
 *
 * \ingroup Hooks
 *
 * \defgroup OSXHooks Customizing OSX
 * \brief Customizing OSX with platform hooks
 *
 * OSX Projects have a file called "osxhooks.mm" which allows a developer to implement hook functionality for OSX specifically for an application.
 *
 * \code
 * void _platform_show_ad() {
 * 	// Call out to your ios ad integration piece here
 * }
 *
 * void _platform_hide_ad() {
 * 	// Call out to your ios ad integration piece here
 * }
 *
 * void _platform_hook(const char *hook, char *result, S32 resultLen) {
 * 	// Handle custom hooks here
 * }
 * \endcode
 *
 * \ingroup Hooks
 */
 
 /**
 * \defgroup OtherPlatform Other Platform Functions
 * \brief Various functions that aren't covered in other modules
 *
 */
 
}

