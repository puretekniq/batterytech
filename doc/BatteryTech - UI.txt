*
* BatteryTech User Interface and Menu System
*
**********************************

User Interface libraries can be very large and cumbersome to meet the demands of every application.  BT's UI library (BTUI) takes the opposite approach.  It is designed primarily to provide menus for mobile games using GLES.  It is very lightweight, has very few components and can do this job very well.


* UIComponent

A UIComponent is a piece of text, button, panel, layout or any other thing that you will find on a UI.  Every BTUI component like Button, Checkbox, etc, extends UIComponent.


* Menus

BTUI is menu-centric.  Menus are the controller and hold the top level UIComponent.  Menus receive the user input for all components that they hold.  Menus instantiate components into a layout.  Each menu in an app must be instantiated and added to the UIManager.


* UIManager

UIManager is used to show and hide menus.  It does a little more than that, though.  It also has a menu stack that it manages.  Every time you show a menu, it pushes that menu onto a stack.  This means you can drill-down in menus and not worry about what menu the last one came from.  Let's examine the methods quickly:

S32 addMenu(Menu *menu);
void showMenu(const char *name);
void showMenu(const char *name, void *data);
void popMenu();
void clearMenuStack();

The first method, addMenu() is what you call from your game to put an instance of a menu in the pool.  Each menu will only have one instance of it which is held throughout the application.  The advantage of this is that the menu will hold its state until the application is closed.  Typical usage:

context->uiManager->addMenu(new TopMenu());

The UIManager will free your menus for you when it is freed, so you don't need to hang on to references to them unless you need them for a different reason.  Just know that it will free for you.

After a menu has been added, showing it is as simple as:

context->uiManager->showMenu(TOP_MENU_NAME); // TOP_MENU_NAME would be declared either in constants or in the TopMenu header itself.

Now the menu will be showing and it will also be on top the menu stack in UIManager.  The menu itself can have a click handler that can remove it from the stack, like so:

context->uiManager->popMenu();

If the stack was empty before showing that menu, nothing will be shown, but if it had any items, the top most item is now the menu displayed in front.

showMenu() can also take a second argument, data.  Being a void pointer, you can send a pointer to anything using this function.  What happens when you use it is that the menu being shown will get a call to void setData(void *data) and being that menus are single-instance, it can store that data or process it in any way which will prepare it for being displayed or having a state set.


* Layouts

The most important thing to understand about BTUI is the LinearLayout.  This UIComponent is the do-all layout and it can be nested, which makes for limitless layout possibilities.  A LinearLayout can be either vertical or horizontal.  Vertical layout stacks the items one on top of another, or bottom up, centered or any combination of the 3.  Horizontal layout does the same, but using left-to-right placement.

mainLayout = new LinearLayout(LinearLayout::VERTICAL);

is a typical way of creating a LinearLayout.  This one will be in the vertical orientation.  Specify HORIZONTAL for horizontal.  Each object added will have its own positioning in the layout and that is specified by the LayoutParameters set to that specific object.  

backButton->setLayoutParameters(new LayoutParameters(LayoutParameters::HORIZONTAL_CENTER, LayoutParameters::TOP));

will set the back button to be centered horizontally and added to the top.  See LayoutParameters.h for all possible options.

Each UIComponent will also specify Size, Margins and Padding.  All units are in what we call "Reference units."


* Reference Units

Very similar to density-independent pixels, reference units are units of relative size to the screen size of the device or window, keeping everything proportionate.  The reference size is specified in batterytech_globals.h 

// What width are you designing your UI to?  This will become your UI width unit.
#define REFERENCE_WIDTH 480
// What height are you designing your UI to?  This will become your UI height unit.
#define REFERENCE_HEIGHT 800

These dimensions are your reference units.  For example, if you use these settings and specify 480x800 as your screen size, then no matter what the actual screen size is, it will appear as 480x800 to your UI for measurement purposes.  It means that if you make a button 480 units wide, that it will ALWAYS be screen-width no matter what the resolution of your target device is!  This delivers very predictable results and makes it very easy to design a user interface that you know will work almost everywhere.

If you change your reference size, you will inevitably have to change all of the numbers you've used for your component sizes and layouts.


* Sizes, Margins and Padding

Every UIComponent can have a Size, Margins and Padding.  These are specified in Reference Units as described above.  Size can have 2 special macros:  FILL and WRAP.  FILL tries to consume all available space while WRAP tries to only use as much as the contents of the UIComponent require.


* Rendering

Rendering for standard BTUI components is handled by MenuRenderer.cpp.  Rendering will be done in either Fixed-Function GL or Shader-based, depending on settings and capabilities.  Resources used for rendering each UIComponent must be specified before the Renderer is initialized.  Specifying resources is very easy.  Here is a complete example of a button being added to a menu with corresponding background images set.


* Working example

S32 buttonBgId = context->menuRenderer->addTextureAsset(UI_BUTTON_1);
S32 buttonPressedBgId = context->menuRenderer->addTextureAsset(UI_BUTTON_1_PRESSED);
backButton = new Button("Back");
backButton->userId = -2;
backButton->setLayoutParameters(new LayoutParameters(LayoutParameters::HORIZONTAL_CENTER, LayoutParameters::TOP));
backButton->setSize(FILL, 60);
backButton->setMargins(5);
backButton->setBackgroundMenuResource(buttonBgId);
backButton->setPressedBackgroundMenuResource(buttonPressedBgId);
backButton->setClickDownSoundAsset(UI_CLICK_DOWN_ASSETNAME);

This button uses the texture defined as UI_BUTTON_1 for unclicked state and UI_BUTTON_1_PRESSED for clicked state.  It will display the text "Back" and will be top centered horizontally.  It will fill up all horizontal area and be 60 units tall.  It will be 5 units in from its container and will play the sound UI_CLICK_DOWN_ASSETNAME when clicked.


* Animation

A simple animation framework is provided that allows you to write your own animators using OpenGL, which is particularly powerful when paired with Shaders.  There is one stock animator (SlideAnimator) that slides components in and out of the menu.  It is used in the demo app and should be a good place to look to learn how to use it.  For custom animators, you will need to extend UIAnimator and implement the following functions:

virtual void update(F32 delta){};
virtual void drawPreComponent(Context *context){};
virtual void drawPostComponent(Context *context){};

update is called every engine tick with delta being the time difference from the last tick.
drawPreComponent is called before the normal drawing routing of UIComponent.
drawPostComponent is called right after normal drawing.  The two methods, used in conjunction, allow for setting up transformations or setting and resetting GL states or anything else.

Each component specifies the animator it will use and for what part of its display the animator will be applied to:

virtual void setEnterAnimator(UIAnimator *animator);
virtual void setMainAnimator(UIAnimator *animator);
virtual void setExitAnimator(UIAnimator *animator);

The "Enter" animator is run when the menu is being shown.
The "Main" animator is run constantly while the component is being shown.
The "Exit" animator is run when the menu is exiting.


* Scrollable Container

The ScrollableContainer class is a layout that can only have one UIComponent.  To make a block of text scrollable, simple create a ScrollableContainer, add the text to it and set the layouts appropriately to allow for multiline text wrapping.  You may add a LinearLayout to the ScrollableContainer instead of a normal UIComponent allowing for multiple components to be scrolled together, which can include labels, buttons, checkboxes or any other component.  Rendering is achieved through the use of glScissor.  Please keep in mind that as of BatteryTech 1.0c, all components in a ScrollableContainer are always rendered in the clipped space, which may be a performance problem depending on your content.  Future optimizations may determine which objects or lines of text are occluded and forego rendering on them.