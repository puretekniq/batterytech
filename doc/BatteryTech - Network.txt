*
* BatteryTech Networking
*
**********************************

BT uses berkley sockets.  What else would you want but the standard?  Well standard is a relative term when it comes to platform implementations.  Fortunately, most OSes use unix sockets but of course Microsoft had to do it their own way just enough to make things slightly incompatible.  BT provides constants and a few functions that smooth out the rough spots and enable normal-looking networking code.

* NetworkManager

For those looking for a quick peer-to-peer TCP networking solution, BT provides a class called NetworkManager.

NetworkManager provides a host mode, client mode and some status and message listener hooks.  The host starts hosting and when a client begins searching for a host, they will find each other and the data connection will start.  Here are the functions:

void startHosting();
void findHost();
void cancelAndClose();
void sendMessage(NetworkMessage *message);
NetworkMessage* createMessage(S32 messageType);

Looks pretty simple, doesn't it?

Both Host and Client need to register listeners (normally your game or other class) using:
void setMessageListener(NetworkMessageListener *listener);
void setStatusListener(NetworkStatusListener *listener);


Host calls:  startHosting()
Client calls: findHost()

and they will receive callbacks via the NetworkStatusListener.

To cancel, they can just call cancelAndClose() and it will quit.  Also if either side quits or network errors occur, the status listener will be called with the new status.

Ports and handshake messages can be all changed in NetworkManager.cpp

Once connected, hosts/clients (we'll call them peers here on out) can send each other messages.  A message is a custom class that represents one or more pieces of data.  

Here is an example NetworkMessage:

// put your different message type constants in your game constants file
#define NETWORK_MESSAGE_TYPE_GAMESTATE 0

// GameStateMessage.h
class GamestateMessage : public NetworkMessage {
public:
	GamestateMessage();
	virtual ~GamestateMessage();
	virtual S32 encode(char *buf);
	virtual void decode(const char *buf, S32 length);
	S32 level;
	U8 gameState;
};

// GameStateMessage.cpp
GamestateMessage::GamestateMessage() : NetworkMessage(NETWORK_MESSAGE_TYPE_GAMESTATE) {
	level = 0;
	gameState = 0;
	payloadLength = 5;
}

GamestateMessage::~GamestateMessage() {
}

S32 GamestateMessage::encode(char *buf) {
	// encode into little endian
	ByteUtil::toBytes(buf, 0, level);
	buf[4] = gameState;
	return payloadLength;
}

void GamestateMessage::decode(const char *buf, S32 length) {
	// decode from little endian
	level = ByteUtil::fromBytesS32(buf, 0);
	gameState = buf[4];
}

And to create this message (and your other message types), you will need a NetworkMessageFactory:

// MyMessageFactory.h
class MyMessageFactory: public NetworkMessageFactory {
public:
	MyMessageFactory: ();
	virtual MyMessageFactory: ();
	virtual NetworkMessage* createMessage(S32 messageType);
};

// MyMessageFactory.cpp

MyMessageFactory::MyMessageFactory() {
}

MyMessageFactory::~MyMessageFactory() {
}

NetworkMessage* MyMessageFactory::createMessage(S32 messageType) {
	if (messageType == NETWORK_MESSAGE_TYPE_GAMESTATE) {
		return new GamestateMessage();
	} else {
		return NULL;
	}
	// add more message types here
}

So if you can see from the code, the MessageFactory instantiates types of messages given by the S32 messageType.  This is used by the NetworkManager to callback to your app with messages received from the network.  You simply set the factory by calling:

MyMessageFactory *myMessageFactory = new MyMessageFactory();
context->networkManager->setMessageFactory(myMessageFactory);

and you will need to delete your message factory on app shutdown as NetworkManager will not do that for you.

The class ByteUtil is provided to easily convert values to bytes and back.  Every 16-64 bit standard type is supported.  

MessageFactory only sends TCP data.  For more advanced networking, using UDP for high performance, it is recommended that you develop your own messaging engine as there are usually more than one type of message (some critical, some not) and that is beyond the scope of BatteryTech.

* A note on NetworkMessage object pooling

NetworkMessages are pooled by the NetworkManager.  They will always be returned to the message pool automatically after sending or receiving.  Just remember:  _never_ instantiate your own messages and send them using this NetworkManager.  You will pollute the pool and cause all types of problems.  Always use the NetworkManager createMessage() function to create a message.  Messages will be returned to the pool automatically after being sent.  See the following:

// this is the correct way to send a gamestate message to the client:

GamestateMessage *msg = context->networkManager->createMessage(NETWORK_MESSAGE_TYPE_GAMESTATE);
msg->level = someLevel;
msg->gameState = GAMESTATE_GAME_OVER;
context->networkManager->sendMessage(msg);

// this is the correct way to handle receiving a message (assuming Game extends NetworkMessageListener)

void Game::onNetworkMessage(NetworkMessage* message) {
if (message->messageType == NETWORK_MESSAGE_TYPE_GAMESTATE) {
	GamestateMessage *gsMessage = (GamestateMessage*) message;
	getWorld()->level = gsMessage->level;
	getWorld()->gameState = gsMessage->gameState;
}

BT provides a few low level functions for networking:

_platform_init_network();
_platform_release_network();
_platform_get_ifaddrs();
_platform_free_ifaddrs();
_platform_make_non_blocking();

These do exactly what you would expect them to do and work on all platforms.  Because networking is a more advanced topic, it is recommended to get a book on BSD (berkley) sockets and see NetworkManager and GameConnection for examples of how to use the various standard socket APIs.

